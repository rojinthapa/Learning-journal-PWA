<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Learning Journal - Journal</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <div id="nav-placeholder"></div>

  <main class="main-content">
    <button id="theme-toggle">Toggle Dark Mode</button> 

    <h1>Learning Journal</h1>

    <!--  Storage API: Journal Entry Form -->
    <section class="card">
      <h2>Write a Journal Entry</h2>
      <form id="entry-form">
        <textarea id="entry-text" rows="5" placeholder="Write your journal entry..."></textarea><br>
        <button type="submit" class="project-link"> Save Entry</button>
      </form>
      <h3 style="margin-top: 1.5rem;">Saved Entries</h3>
      <ul id="entry-list" style="list-style: none; padding-left: 0;"></ul>
    </section>

<!--  JSON Backend Data Section -->
<section class="card">
    <h2>Python JSON Reflections</h2>
    <div class="json-controls">
        <button id="load-json" class="project-link"> Load JSON Reflections</button>
        <button id="export-json" class="project-link"> Export JSON</button>
        <span id="reflection-count" style="margin-left: 1rem; font-weight: bold;"></span>
    </div>
    <div id="json-reflections" class="reflections-container"></div>
</section>


    <!--  Third-Party API: YouTube Embed -->
    <section class="card">
      <h2>Helpful Tutorial</h2>
      <div id="youtube-video"></div>
    </section>

    <!--  Week 4 Entry -->
    <div class="journal-entry">
      <h3>Week 4 – APIs & Progressive Enhancement</h3>
      <p><strong>Topics Covered:</strong> Storage API, Notification API, Third-Party API (YouTube), Modular JavaScript, DOM Integration</p>

      <h4>Journal Questions:</h4>

      <p><strong>Which Storage, Browser, and Third-Party APIs did you choose, and why?</strong></p>
      <p>I chose <strong>localStorage</strong> to persist journal entries across sessions because it's simple and reliable for small text data. For the Browser API, I used the <strong>Notification API</strong> to alert users when a new entry is saved — it adds a nice interactive touch. As a Third-Party API, I embedded a <strong>YouTube tutorial</strong> dynamically using an iframe, allowing me to share helpful videos directly inside the journal.</p>

      <p><strong>How did you integrate each API with DOM manipulation?</strong></p>
      <p>I used <code>getElementById()</code> to target the form and textarea, then added a <code>submit</code> event listener. When submitted, the entry is saved to <code>localStorage</code> and displayed using <code>innerHTML</code>. The Notification API is triggered after saving, using <code>new Notification()</code>. The YouTube embed is injected into a container using <code>innerHTML</code> to keep the HTML clean and dynamic.</p>

      <p><strong>What challenges did you encounter, and how did you solve them?</strong></p>
      <p>Notification permissions were tricky — some browsers block them by default. I requested permission on page load and added fallback logic. Modularizing the JavaScript into four files required careful planning, which I solved by grouping related logic and loading scripts in order. I also wrapped all logic in <code>DOMContentLoaded</code> to ensure DOM elements were ready before attaching listeners.</p>

      <p><strong>In what ways do these APIs improve your Learning Journal PWA?</strong></p>
      <p>The Storage API makes the journal feel like a real app — entries persist even after closing the browser. Notifications give instant feedback, improving user experience. The YouTube embed adds multimedia learning value. Together, these APIs make the journal more interactive, dynamic, and user-friendly — exactly what a modern PWA should be.</p>
    </div>

    <!--  Week 3 Entry (Unchanged) -->
    <div class="journal-entry">
      <h3>Week 3 - JavaScript & DOM Manipulation</h3>
      <p><strong>Topics Covered:</strong> HTML DOM Manipulation, Reusable Components, Event Handling, Theme Switching, Date Object.</p>
      
      <h4>Journal Questions:</h4>
      
      <p><strong>Which DOM selection methods did you use, and why did you choose them?</strong></p>
      <p>I utilized two primary DOM selection methods:</p>
      <ul>
        <li><strong>document.getElementById()</strong>: This was the primary selection method used for targeting unique elements like the <code>#nav-placeholder</code>, <code>#theme-toggle</code>, and the <code>#live-date-time</code> display. I chose this because it is the fastest and most direct way to get an element by its ID.</li>
        <li><strong>document.querySelectorAll('.nav-menu a')</strong>: This was essential for selecting <strong>multiple</strong> navigation links (the anchors within the nav menu) so I could iterate through them and correctly apply the <strong>active</strong> CSS class. This method allowed me to easily target the elements needed for highlighting the current page.</li>
      </ul>
      
      <p><strong>What was the most challenging part about linking JavaScript with your HTML?</strong></p>
      <p>A challenge was ensuring all necessary DOM elements were fully loaded before the script attempted to manipulate them. Placing the <code>&lt;script&gt;</code> tag right before the closing <code>&lt;/body&gt;</code> tag guaranteed this, allowing the JavaScript to correctly inject the navigation and attach event listeners. Managing the logic to dynamically assign the <code>active</code> class to the navigation link, especially handling root URLs versus <code>index.html</code>, also required careful attention.</p>
      
      <p><strong>How did you test and debug your JavaScript code?</strong></p>
      <ul>
        <li><strong>Console</strong>: I used <code>console.log()</code> to verify the output of variables (like the current URL path or the <code>Date()</code> object) and confirm event handlers were firing correctly.</li>
        <li><strong>Elements Tab</strong>: I inspected the HTML structure to visually confirm that the <code>&lt;nav&gt;</code> block was correctly injected into the <code>#nav-placeholder</code> and that the <code>body</code> element gained the <code>dark-mode</code> class (confirming the CSS style change) when the theme switcher was clicked.</li>
        <li><strong>Sources Tab</strong>: I set <strong>breakpoints</strong> within <code>script.js</code> to step through the logic line-by-line, which was useful for debugging the event handling and the navigation's active state assignment.</li>
      </ul>
    </div>

    <!--  Week 2 Entry (Unchanged) -->
    <div class="journal-entry">
      <h3>Week 2 - Frontend Fundamentals</h3> 
      <p><strong>Topics Covered:</strong> HTML5, CSS3, Mobile-First Design, Responsive Layouts</p>
      
      <h4>Journal Questions:</h4>
      <p><strong>How did you approach mobile-first design?</strong></p>
      <p>I started by designing for mobile screens first, using a single column layout and larger touch targets. Then I used CSS media queries to add more complex layouts for tablets and desktops. This ensured the core experience worked well on all devices.</p>
      
      <p><strong>What was the most useful HTML or CSS concept you applied this week?</strong></p>
      <p>The most useful concept was CSS Grid and Flexbox for creating responsive layouts. Media queries were also essential for adapting the design across different screen sizes without changing the HTML structure.</p>
      
      <p><strong>What part of HTML or CSS did you find most challenging or confusing?</strong></p>
      <p>The most challenging part was ensuring perfect cross-browser compatibility and dealing with GitHub's limitation of not allowing empty folders. I had to add placeholder files to maintain the folder structure in the repository.</p>
    </div>

    <!--  Week 1 Entry (Unchanged) -->
    <div class="journal-entry">
      <h3>Week 1 - Introduction to PWA & Development Setup</h3>
      <p><strong>Topics Covered:</strong> PWA Basics, GitHub Setup, VS Code Integration, PythonAnywhere Deployment</p>
      
      <h4>Tasks Completed:</h4>
      <ul>
        <li>Created GitHub account and TemperatureConverterPWA repository</li>
        <li>Set up VS Code with GitHub integration</li>
        <li>Built a Temperature Converter PWA with manifest and service worker</li>
        <li>Deployed the PWA on GitHub Pages and PythonAnywhere</li>
        <li>Explored Android Studio and Kotlin for mobile development</li>
      </ul>
      
            <h4>Challenges Faced:</h4>
      <p><strong>GitHub Empty Folders:</strong> GitHub doesn't allow empty folders, so I had to add placeholder files (.gitkeep) to maintain the project structure.</p>

      <p><strong>Mobile-PC Compatibility:</strong> Adjusting the PWA to work seamlessly across different devices was challenging. I had to test extensively on various screen sizes and use responsive design principles.</p>

      <p><strong>Service Worker Setup:</strong> Getting the service worker to properly cache resources for offline functionality required careful path configuration and testing.</p>

      <h4>Reflection:</h4>
      <p>This week provided a comprehensive introduction to the mobile development ecosystem. Setting up the development environment across multiple platforms (GitHub, VS Code, PythonAnywhere, Android Studio) was initially overwhelming but ultimately rewarding. The PWA approach is particularly interesting as it bridges web and mobile development.</p>

      <p>The most valuable lesson was understanding how different deployment platforms serve different purposes - GitHub Pages for static hosting, PythonAnywhere for potential backend services, and Android Studio for native mobile apps.</p>
    </div>
  </main>

  <footer>
    <p>&copy; 2025 My Learning Journal. All rights reserved.</p>
  </footer>

  <!-- Modular JS files -->
<script src="js/script.js"></script>
<script src="js/storage.js"></script>
<script src="js/browser.js"></script>
<script src="js/thirdparty.js"></script>
<script src="js/json-handler.js"></script>  
</body>
</html>
